{
  "language": "Solidity",
  "sources": {
    "contracts/DaoContract.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"./IDaoContract.sol\";\nimport \"./IRoleHandler.sol\";\n\n\ncontract DaoFactory {\n    function createDao(address _parent, address[] memory _initialCitizens, address _daoFactory) public returns (address) {\n        DaoContract newDao = new DaoContract(_parent, _initialCitizens, _daoFactory);\n        return address(newDao);\n    }\n}\n\ncontract DaoContract is IDaoContract {\n    mapping(address => mapping(uint256 => bool)) public roles;\n\n    mapping(uint256 => uint256) public roleCount;\n\n    mapping(uint256 => IRoleHandler) public roleHandlers;\n    \n    address public parentDao;\n\n    modifier onlyGovernance() {\n        _;\n    }\n\n    enum ProposalType{NONE, TEXT, CALL, CREATE_SUBDAO}\n\n    struct Proposal {\n        ProposalType pType;\n        string description;\n        address target;\n        uint256 amount;\n        bytes fun;\n        bytes data;\n        uint256 support;\n        uint256 totalVotes;\n        bool executed;\n        uint256 deadline;\n        bool executionSuccess;\n        bytes executionResult;\n    }\n\n    mapping(uint256 => mapping(address => bool)) public proposalVotes;\n\n    mapping(uint256 => Proposal) public proposals;\n    uint256 public proposalCount;\n    \n    DaoFactory public daoFactory;\n    address[] public subDAOs;\n    \n    constructor(address _parentDao, address[] memory _initialCitizens, address _daoFactory) {\n        require(_initialCitizens.length > 0, \"At least one initial citizen required\");\n        parentDao = _parentDao;\n  \n        // Assign initial citizens to a role, e.g., role 1\n        for (uint i = 0; i < _initialCitizens.length; i++) {\n            roles[_initialCitizens[i]][1] = true; // Assuming role 1 is for citizens\n            roleCount[1]++;\n        }\n        daoFactory = DaoFactory(_daoFactory);\n    }\n\n    function getProposal(uint256 proposalId) public view returns (Proposal memory proposal) {\n        return proposals[proposalId];\n    }\n    \n    function getProposal(uint256 from, uint256 count) public view returns (Proposal[] memory proposalsOut) {\n        count = (from + count <= proposalCount) ? count :  proposalCount - from;\n        proposalsOut = new Proposal[](count);\n        for (uint i = 0 ; from + i < proposalCount && i < count; i++) {\n            proposalsOut[i] = proposals[from + i];\n        }\n    }\n\n    function createProposal(\n        ProposalType pType,\n        string memory description,\n        address target,\n        uint256 amount,\n        bytes memory funToCall,\n        bytes memory data,\n        uint256 duration\n    ) public {\n        require(pType == ProposalType.TEXT || pType == ProposalType.CALL || pType == ProposalType.CREATE_SUBDAO, \"Invalid proposal type\");\n        require(pType != ProposalType.CREATE_SUBDAO || target == address(0), \"SubDAO proposals must not have a target\");\n        Proposal storage proposal = proposals[proposalCount++];\n        proposal.pType = pType;\n        proposal.description = description;\n        proposal.target = target;\n        proposal.amount = amount;\n        proposal.fun = funToCall;\n        proposal.data = data;\n        proposal.deadline = block.timestamp + duration;\n    }\n\n    function voteOnProposal(uint256 proposalId, bool supportVote) public {\n        require(roles[msg.sender][1], \"Not authorized to vote\");\n        Proposal storage proposal = proposals[proposalId];\n        require(!proposal.executed, \"Proposal already executed\");\n        require(block.timestamp < proposal.deadline, \"Voting period has ended\");\n        require(!proposalVotes[proposalId][msg.sender], \"Already voted\");\n\n\n        proposalVotes[proposalId][msg.sender] = true;\n        proposal.totalVotes += 1;\n        if (supportVote) {\n            proposal.support += 1;\n        }\n    }\n\n    function checkProposalPassed(uint256 proposalId) internal view returns (bool) {\n        Proposal storage proposal = proposals[proposalId];\n        uint256 requiredSupport = (roleCount[1] * 66) / 100;\n        return proposal.support >= requiredSupport && proposal.totalVotes - proposal.support <= (roleCount[1] * (100 - 66)) / 100;\n    }\n\n    function executeProposal(uint256 proposalId) public {\n        Proposal storage proposal = proposals[proposalId];\n        require(!proposal.executed, \"Proposal already executed\");\n        require(block.timestamp < proposal.deadline, \"Proposal has expired\");\n\n        if (checkProposalPassed(proposalId)) {\n            proposal.executed = true;\n            if (proposal.pType == ProposalType.CALL) {\n                (bool success, bytes memory result) = executeCallProposal(proposal);\n                proposal.executionSuccess = success;\n                proposal.executionResult = result;\n            } else if (proposal.pType == ProposalType.CREATE_SUBDAO) {\n                createSubDAO(proposal);\n            }\n            // Add logic for other types of proposals if needed\n        } else {\n            revert(\"Proposal did not pass\");\n        }\n    }\n\n    function executeCallProposal(Proposal storage proposal) internal returns (bool, bytes memory) {\n        require(proposal.target != address(0), \"Invalid target address\");\n\n        // Hash the function signature string to get the function selector\n        bytes4 funcSelector = bytes4(keccak256(bytes(proposal.fun)));\n        \n        // Concatenate the function selector with the parameters\n        bytes memory payload = abi.encodePacked(funcSelector, proposal.data);\n        (bool success, bytes memory result) = proposal.target.call{value: proposal.amount}(payload);\n        return (success, result);\n    }\n \n    function createSubDAO(Proposal storage proposal) internal {\n        require(proposal.pType == ProposalType.CREATE_SUBDAO, \"Invalid proposal type\");\n\n        address[] memory initialCitizens = abi.decode(proposal.data, (address[]));\n \n        DaoContract newSubDAO = DaoContract(daoFactory.createDao(address(this), initialCitizens, address(daoFactory)));\n        subDAOs.push(address(newSubDAO));\n\n        // Additional    initialization for newSubDAO if required\n    }\n\n    function delegateVoting(address delegate) public {\n        // Delegate voting rights\n    }\n\n    // Function to create a proposal for registering a role handler\n    function createRegisterRoleHandlerProposal(uint256 role, address handlerAddress, uint256 duration) public {\n        // Function definition as a string\n        string memory functionDefinition = \"internalRegisterRoleHandler(uint256,address)\";\n\n        // Convert function definition from string to bytes\n        bytes memory functionDefinitionBytes = bytes(functionDefinition);\n\n        // Encode only the parameters\n        bytes memory parameters = abi.encode(role, handlerAddress);\n\n        // Create a CALL type proposal in the IdentityHandler DAO\n        createProposal(ProposalType.CALL, \"Register Role Handler\", address(this), 0, functionDefinitionBytes, parameters, duration);\n    }\n\n    // Internal function to register a role handler\n    function internalRegisterRoleHandler(uint256 role, address handlerAddress) external {\n        require(msg.sender == address(this), \"Unauthorized\");\n        require(role > 0, \"Must be > 0\");\n        roleHandlers[role] = IRoleHandler(handlerAddress);\n    }\n\n    // register entityType handler\n    function registerRoleHandler(uint256 role, address handlerAddress) external onlyGovernance {\n        require(role > 0, \"Must be > 0\");\n        roleHandlers[role] = IRoleHandler(handlerAddress);\n    }\n\n\n    // Functions\n    function assignRole(address entityAddress, uint256 role) public {\n        // Record property ownership / add new property to the register\n        require(address(roleHandlers[role]) == msg.sender || msg.sender == address(this), \"Only matching role handler handler\");\n        if (!roles[entityAddress][role]) {\n            roleCount[role]++;\n            roles[entityAddress][role] = true;\n        }\n    }\n    \n    function revokeRole(address entityAddress, uint256 role) public {\n        // Record property ownership / add new property to the register\n        require(address(roleHandlers[role]) == msg.sender || msg.sender == address(this), \"Only matching role handler handler\");\n        if (roles[entityAddress][role]) {\n            require(roleCount[role] > 1 || role != 1, \"Dont kill the last citizen\");\n            roleCount[role]--;\n            roles[entityAddress][role] = false;\n        }\n    }\n\n}\n"
    },
    "contracts/IDaoContract.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IDaoContract {\n    // register entityType handler\n    function registerRoleHandler(uint256 role, address handlerAddress) external;\n    function assignRole(address entityAddress, uint256 role) external;\n    function revokeRole(address entityAddress, uint256 role) external;\n}\n"
    },
    "contracts/IdentityHandler.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"./DaoContract.sol\";\r\n\r\ncontract IdentityHandler is DaoContract {\r\n    mapping(address => uint256) public stakes;\r\n\r\n    // Mapping to store delegations: roleType => delegate address\r\n    mapping(uint256 => address) public roleDelegations;\r\n\r\n    // Assuming a required stake amount is defined\r\n    uint256 public requiredStakeAmount;\r\n\r\n    // Constructor\r\n    constructor(address _parentDaoAddress, address[] memory _initialCitizens, address _daoFactory, uint256 _requiredStakeAmount)\r\n        DaoContract(_parentDaoAddress, _initialCitizens, _daoFactory) {\r\n            requiredStakeAmount = _requiredStakeAmount;\r\n    }\r\n\r\n\r\n    // Function to stake tokens (details to be implemented based on your token logic)\r\n    function stake(address user, uint256 amount) external {\r\n        // Assuming the staking logic is implemented here\r\n        stakes[user] = amount;\r\n    }\r\n\r\n  // Function to create a proposal for assigning a role\r\n    function createAssignRoleProposal(address user, uint256 role, uint256 duration) public {\r\n        // Function definition as a string\r\n        string memory functionDefinition = \"internalAssignRole(address,uint256)\";\r\n\r\n        // Convert function definition from string to bytes\r\n        bytes memory functionDefinitionBytes = bytes(functionDefinition);\r\n\r\n        // Encode only the parameters\r\n        bytes memory parameters = abi.encode(user, role);\r\n\r\n        // Create a CALL type proposal in the IdentityHandler DAO\r\n        createProposal(ProposalType.CALL, \"Assign Role\", address(this), 0, functionDefinitionBytes, parameters, duration);\r\n    }\r\n\r\n\r\n    // Internal function to be called by the proposal execution\r\n    function internalAssignRole(address user, uint256 role) external {\r\n        require(msg.sender == address(this), \"Unauthorized\");\r\n        DaoContract(parentDao).assignRole(user, role); // Call assignRole on the main DAO\r\n    }\r\n\r\n    function createRevokeRoleProposal(address user, uint256 role, uint256 duration) public {\r\n        // Function definition as a string\r\n        string memory functionDefinition = \"internalRevokeRole(address,uint256)\";\r\n\r\n        // Encode only the parameters\r\n        bytes memory parameters = abi.encode(user, role);\r\n\r\n        // Create a CALL type proposal in the IdentityHandler DAO\r\n        createProposal(ProposalType.CALL, \"Revoke Role\", address(this), 0, bytes(functionDefinition), parameters, duration);\r\n    }\r\n\r\n\r\n    // Internal function to be called by the proposal execution\r\n    function internalRevokeRole(address user, uint256 role) external {\r\n        require(msg.sender == address(this), \"Unauthorized\");\r\n        DaoContract(parentDao).revokeRole(user, role); // Call revokeRole on the main DAO\r\n    }\r\n\r\n    // Function to create a proposal for delegating a role type\r\n    function createDelegateRoleTypeProposal(uint256 roleType, address delegate, uint256 duration) public {\r\n        // Function definition as a string\r\n        string memory functionDefinition = \"internalDelegateRoleType(uint256,address)\";\r\n\r\n        // Convert function definition from string to bytes\r\n        bytes memory functionDefinitionBytes = bytes(functionDefinition);\r\n\r\n        // Encode only the parameters\r\n        bytes memory parameters = abi.encode(roleType, delegate);\r\n\r\n        // Create a CALL type proposal in the IdentityHandler DAO\r\n        createProposal(ProposalType.CALL, \"Delegate Role Type\", address(this), 0, functionDefinitionBytes, parameters, duration);\r\n    }\r\n\r\n    // Internal function to be called by the proposal execution\r\n    function internalDelegateRoleType(uint256 roleType, address delegate) external {\r\n        require(msg.sender == address(this), \"Unauthorized\");\r\n        roleDelegations[roleType] = delegate; // Delegate the role type\r\n    }\r\n\r\n    // Function to assign a role if it's delegated\r\n    function delegatedAssignRole(address entityAddress, uint256 role) external {\r\n        address delegate = roleDelegations[role];\r\n        if (delegate != address(0) && msg.sender == delegate) {\r\n            // Role type is delegated and the caller is the delegate,\r\n            // proxy the call to the main DAO\r\n            DaoContract(parentDao).assignRole(entityAddress, role);\r\n        }\r\n        // No action if the role is not delegated or the caller is not the delegate\r\n    }\r\n\r\n    // Function to revoke a role if it's delegated\r\n    function delegatedRevokeRole(address entityAddress, uint256 role) external {\r\n        address delegate = roleDelegations[role];\r\n        if (delegate != address(0) && msg.sender == delegate) {\r\n            // Role type is delegated and the caller is the delegate,\r\n            // proxy the call to the main DAO\r\n            DaoContract(parentDao).revokeRole(entityAddress, role);\r\n        }\r\n        // No action if the role is not delegated or the caller is not the delegate\r\n    }\r\n}\r\n"
    },
    "contracts/IRoleHandler.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IRoleHandler {\n    \n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}